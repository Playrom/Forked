{"metadata":{"title":"Getting Started with Forked","role":"article","modules":[{"name":"Forked"}],"roleHeading":"Article"},"seeAlsoSections":[{"anchor":"Essentials","generated":true,"identifiers":["doc:\/\/Forked\/documentation\/Forked\/ForkedResource","doc:\/\/Forked\/documentation\/Forked\/Mergeable","doc:\/\/Forked\/documentation\/Forked\/Repository"],"title":"Essentials"}],"hierarchy":{"paths":[["doc:\/\/Forked\/documentation\/Forked"]]},"sections":[],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/forked\/gettingstarted"]}],"kind":"article","schemaVersion":{"patch":0,"major":0,"minor":3},"abstract":[{"type":"text","text":"Learn how to use Forked to manage shared data in your Swift applications."}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/GettingStarted"},"primaryContentSections":[{"kind":"content","content":[{"level":2,"type":"heading","anchor":"Overview","text":"Overview"},{"inlineContent":[{"type":"text","text":"Forked provides a safe way to handle shared data by allowing you to create independent branches (forks) of your data that can be modified concurrently and merged later. This guide will walk you through the basic concepts using practical examples."}],"type":"paragraph"},{"type":"heading","level":2,"text":"Creating Your First Resource","anchor":"Creating-Your-First-Resource"},{"inlineContent":[{"type":"text","text":"The easiest way to get started is with "},{"type":"reference","identifier":"doc:\/\/Forked\/documentation\/Forked\/QuickFork","isActive":true},{"type":"text","text":", which manages a single value in memory:"}],"type":"paragraph"},{"code":["import Forked","","\/\/ Create a QuickFork holding an integer","let counter = QuickFork<Int>(initialValue: 0)","","\/\/ Read the initial value from the main fork","let value = try counter.value(in: .main)! \/\/ Returns 0"],"type":"codeListing","syntax":"swift"},{"name":"Note","type":"aside","style":"note","content":[{"inlineContent":[{"text":"","type":"text"},{"code":"value(in:)","type":"codeVoice"},{"text":" returns an optional because the value might not exist in a given fork. When you’re sure the value exists (like right after creation), you can force unwrap with ","type":"text"},{"type":"codeVoice","code":"!"},{"type":"text","text":". In production code, you might want to handle the optional more safely."}],"type":"paragraph"}]},{"level":2,"anchor":"Working-with-Forks","type":"heading","text":"Working with Forks"},{"type":"heading","text":"Creating Named Forks","level":3,"anchor":"Creating-Named-Forks"},{"inlineContent":[{"type":"text","text":"While every resource has a "},{"type":"codeVoice","code":".main"},{"type":"text","text":" fork, you’ll often want to create additional named forks. One convenient approach is to define your forks as static properties in an extension to "},{"code":"Fork","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["extension Fork {","    static let ui = Fork(name: \"ui\")","    static let background = Fork(name: \"background\")","    static let network = Fork(name: \"network\")","}","","\/\/ Create a resource with multiple forks","let counter = QuickFork<Int>(","    initialValue: 0,","    forks: [.ui, .background, .network]",")","","\/\/ Using static properties makes the code more readable","try counter.update(.ui, with: 1)","try counter.mergeIntoMain(from: .ui)"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"You can also create forks directly if you prefer:","type":"text"}]},{"syntax":"swift","code":["let customFork = Fork(name: \"custom\")"],"type":"codeListing"},{"type":"heading","level":3,"text":"Updating Values","anchor":"Updating-Values"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can update values independently in different forks:"}]},{"syntax":"swift","code":["\/\/ Update values directly","try counter.update(.ui, with: 1)","try counter.update(.main, with: 2)","","\/\/ Each fork maintains its own value","let uiValue = try counter.value(in: .ui)!      \/\/ Returns 1","let mainValue = try counter.value(in: .main)!     \/\/ Returns 2"],"type":"codeListing"},{"anchor":"Merging-Changes","text":"Merging Changes","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"When you’re ready to reconcile changes between forks, you can merge them. All merges must go through the ","type":"text"},{"type":"codeVoice","code":"main"},{"type":"text","text":" fork - you cannot merge directly between custom forks:"}]},{"syntax":"swift","code":["\/\/ Merge the UI fork into main","try counter.mergeIntoMain(from: .ui)","","\/\/ To get changes from UI fork to background fork:","\/\/ 1. First merge UI into main (as above)","\/\/ 2. Then merge from main into background","try counter.mergeFromMain(into: .background)"],"type":"codeListing"},{"anchor":"Merging-Direction","level":3,"type":"heading","text":"Merging Direction"},{"type":"paragraph","inlineContent":[{"text":"Merging is directional - changes flow from the source fork to the destination fork. To fully synchronize two forks, you need to merge in both directions:","type":"text"}]},{"syntax":"swift","code":["\/\/ Merge changes from UI to main","try counter.mergeIntoMain(from: .ui)","","\/\/ Merge changes from main to UI","try counter.mergeFromMain(into: .ui)"],"type":"codeListing"},{"inlineContent":[{"text":"For convenience, there’s a ","type":"text"},{"type":"codeVoice","code":"syncMain(with:)"},{"text":" method that performs bidirectional merges between main and multiple forks:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/ Synchronize main with UI and background forks","try counter.syncMain(with: [.ui, .background])"]},{"type":"paragraph","inlineContent":[{"text":"Remember that syncing between custom forks still requires going through ","type":"text"},{"code":"main","type":"codeVoice"},{"type":"text","text":". The sync method makes this easier by handling all the necessary merges in each direction."}]},{"level":2,"text":"Working with Complex Types","anchor":"Working-with-Complex-Types","type":"heading"},{"inlineContent":[{"text":"While the examples above use simple ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values, Forked really shines when working with complex types. Here’s an example using a custom type:"}],"type":"paragraph"},{"code":["struct Counter: Mergeable {","    var count: Int = 0","    ","    \/\/ Define how instances should be merged","    func merged(withSubordinate other: Self, commonAncestor: Self) throws -> Self {","        \/\/ Add the changes from both forks","        let selfDelta = self.count - commonAncestor.count","        let otherDelta = other.count - commonAncestor.count","        return Counter(count: commonAncestor.count + selfDelta + otherDelta)","    }","}","","\/\/ Create a resource with our custom type","let counter = QuickFork<Counter>(","    initialValue: Counter(),","    forks: [.ui, .background]",")","","\/\/ Update values in different forks","var uiCounter = try counter.value(in: .ui)!","uiCounter.count += 1","try counter.update(.ui, with: uiCounter)","","var mainCounter = try counter.value(in: .main)!","mainCounter.count += 2","try counter.update(.main, with: mainCounter)","","\/\/ Merge the changes","try counter.mergeIntoMain(from: .ui)","","\/\/ Both increments are preserved","let result = try counter.value(in: .main)!.count \/\/ Returns 3"],"syntax":"swift","type":"codeListing"},{"level":2,"text":"Next Steps","type":"heading","anchor":"Next-Steps"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Learn about different merging strategies in ","type":"text"},{"text":"doc:MergingStrategy","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Explore automatic model generation with "},{"type":"codeVoice","code":"ForkedModel"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Add CloudKit sync with "},{"type":"codeVoice","code":"ForkedCloudKit"}],"type":"paragraph"}]}]}]}],"references":{"doc://Forked/documentation/Forked/QuickFork":{"role":"symbol","url":"\/documentation\/forked\/quickfork","type":"topic","kind":"symbol","identifier":"doc:\/\/Forked\/documentation\/Forked\/QuickFork","title":"QuickFork","fragments":[{"text":"typealias","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"QuickFork"}],"navigatorTitle":[{"kind":"identifier","text":"QuickFork"}],"abstract":[]},"doc://Forked/documentation/Forked/Mergeable":{"type":"topic","url":"\/documentation\/forked\/mergeable","role":"symbol","identifier":"doc:\/\/Forked\/documentation\/Forked\/Mergeable","navigatorTitle":[{"kind":"identifier","text":"Mergeable"}],"fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Mergeable"}],"title":"Mergeable","kind":"symbol","abstract":[]},"doc://Forked/documentation/Forked":{"url":"\/documentation\/forked","identifier":"doc:\/\/Forked\/documentation\/Forked","role":"collection","abstract":[{"type":"text","text":"A framework for handling shared data with confidence in Swift."}],"title":"Forked","type":"topic","kind":"symbol"},"doc://Forked/documentation/Forked/ForkedResource":{"title":"ForkedResource","fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"text":"ForkedResource","kind":"identifier"}],"abstract":[{"type":"text","text":"This manages forks of a resource. It facilitiates concurrent changes to a single resource, and"},{"type":"text","text":" "},{"text":"provides a systematic approach for merging changes, with support for 3-way merging.","type":"text"}],"url":"\/documentation\/forked\/forkedresource","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ForkedResource"}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource"},"doc://Forked/documentation/Forked/Repository":{"fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"Repository","kind":"identifier"}],"abstract":[{"text":"This is storage for the ","type":"text"},{"code":"ForkedResource","type":"codeVoice"},{"text":". It could","type":"text"},{"type":"text","text":" "},{"type":"text","text":"be persisted on disk, or just kept in memory."},{"text":" ","type":"text"},{"type":"text","text":"This type does not understand any of the mechanisms of forking"},{"type":"text","text":" "},{"text":"and merging. That is all handled by the ","type":"text"},{"type":"codeVoice","code":"ForkedResource"},{"type":"text","text":", which also"},{"text":" ","type":"text"},{"type":"text","text":"ensures correct multi-threading behavior."},{"type":"text","text":" "},{"text":"Classes conforming to this type simply have to setup a storage","type":"text"},{"type":"text","text":" "},{"type":"text","text":"mechanism, and handle the requests, keeping commits assigned to forks."}],"kind":"symbol","role":"symbol","url":"\/documentation\/forked\/repository","navigatorTitle":[{"text":"Repository","kind":"identifier"}],"type":"topic","title":"Repository","identifier":"doc:\/\/Forked\/documentation\/Forked\/Repository"}}}