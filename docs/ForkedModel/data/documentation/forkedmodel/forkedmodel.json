{"hierarchy":{"paths":[["doc:\/\/ForkedModel\/documentation\/ForkedModel"]]},"abstract":[{"text":"Create mergeable data models using Swift value types.","type":"text"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/forkedmodel\/forkedmodel"]}],"metadata":{"title":"ForkedModel","role":"article","roleHeading":"Article","modules":[{"name":"ForkedModel"}]},"primaryContentSections":[{"kind":"content","content":[{"text":"Overview","type":"heading","anchor":"Overview","level":2},{"inlineContent":[{"text":"ForkedModel provides a simple way to define data models using Swift value types (","type":"text"},{"type":"emphasis","inlineContent":[{"text":"ie","type":"text"}]},{"text":" structs), which can be safely merged when concurrent changes occur. Attaching the ","type":"text"},{"type":"codeVoice","code":"@ForkedModel"},{"type":"text","text":" macro to a "},{"type":"codeVoice","code":"struct"},{"type":"text","text":", you can create a data model that can handle property-wise merging with sophisticated algorithms."}],"type":"paragraph"},{"inlineContent":[{"text":"A mergeable model is useful for handling concurrent changes to data within your app, between processes (","type":"text"},{"inlineContent":[{"type":"text","text":"eg"}],"type":"emphasis"},{"text":" extensions), and even between devices if you are syncing with iCloud. Adopting ","type":"text"},{"code":"@ForkedModel","type":"codeVoice"},{"text":" takes very little effort, has very little risk since your model is comprised of standard structs, and prepares your app for whatever data concurrency challenges may arise.","type":"text"}],"type":"paragraph"},{"type":"heading","text":"Creating a Basic Model","anchor":"Creating-a-Basic-Model","level":2},{"inlineContent":[{"text":"You create a mergeable model using the ","type":"text"},{"type":"codeVoice","code":"@ForkedModel"},{"type":"text","text":" macro:"}],"type":"paragraph"},{"code":["@ForkedModel ","struct User {","    var name: String = \"\"","    var age: Int = 0","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The attributes in this model will be merged using a “most recent wins” strategy — if both forks modify the same property, the most recent change will be kept.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Note that equatable properties will be merged in a property-wise fashion. If the ","type":"text"},{"type":"codeVoice","code":"name"},{"type":"text","text":" property is modified in one fork, and the "},{"code":"age","type":"codeVoice"},{"text":" property is modified in another, the most recent of each property will be kept when merging. This is different to just choosing the most recent value of the struct, which does not consider how the individual properties have changed.","type":"text"}]},{"type":"aside","style":"note","name":"Note","content":[{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"@ForkedModel"},{"type":"text","text":" macro generates a standard Swift struct with an extension that conforms to "},{"code":"Mergeable","type":"codeVoice"},{"text":". There is no runtime overhead or magic - just pure Swift value types with some helper functions to facilitate merging. The generated struct can be used the same as any other struct, including adding ","type":"text"},{"type":"codeVoice","code":"Codable"},{"type":"text","text":" conformance to save or work with a web service."}],"type":"paragraph"}]},{"text":"Using `@Merged` Properties","type":"heading","anchor":"Using-Merged-Properties","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"@Merged"},{"text":" macro works alongside ","type":"text"},{"type":"codeVoice","code":"@ForkedModel"},{"type":"text","text":", specifying how specific properties should be merged when conflicts arise. By default, "},{"type":"codeVoice","code":"@Merged"},{"text":" will choose an appropriate merging strategy based on the property type:","type":"text"}]},{"syntax":"swift","code":["@ForkedModel","struct Note {","    @Merged var title: String = \"\"             \/\/ Uses a text merging algorithm","    @Merged var tags: Set<String> = []         \/\/ Uses a special set merging algorithm","    @Merged var pages: [String] = []           \/\/ Uses array merging algorithm","    @Merged var metadata: [String:Int] = [:]   \/\/ Uses dictionary merging","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The algorithms for merging these properties are quite sophisticated. They utilize state-of-the-art algorithms known as Conflict-free Replicated Data Types (CRDTs). These algorithms aim to generate a result that is consistent with the expectations of people, rather than just convenient to program.","type":"text"}]},{"type":"heading","level":3,"anchor":"Default-Merging-Strategies","text":"Default Merging Strategies"},{"inlineContent":[{"type":"text","text":"When using the "},{"type":"codeVoice","code":"@Merged"},{"text":" macro, each type has a default merging algorithm, but you can also specify a different algorithm. The default merging strategies are:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"String"},{"type":"text","text":" properties use "},{"type":"codeVoice","code":".textMerge"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"Array","type":"codeVoice"},{"text":" properties use ","type":"text"},{"code":".arrayMerge","type":"codeVoice"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Set"},{"type":"text","text":" properties use "},{"type":"codeVoice","code":".setMerge"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"Dictionary","type":"codeVoice"},{"type":"text","text":" properties use "},{"code":".dictionaryMerge","type":"codeVoice"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Types that conform to "},{"code":"Mergeable","type":"codeVoice"},{"text":" use their own merging implementation","type":"text"}]}]}],"type":"unorderedList"},{"type":"heading","anchor":"Customizing-Merge-Behavior","level":2,"text":"Customizing Merge Behavior"},{"type":"paragraph","inlineContent":[{"text":"You can explicitly specify which merging algorithm to use with the ","type":"text"},{"type":"codeVoice","code":"using:"},{"type":"text","text":" parameter on "},{"type":"codeVoice","code":"@Merged"},{"type":"text","text":":"}]},{"code":["@ForkedModel","struct Document {","    \/\/ Explicitly use text merging for string content","    @Merged(using: .textMerge) var content: String = \"\"","    ","    \/\/ Use array merging for ordered lists","    @Merged(using: .arrayMerge) var sections: [String] = []","    ","    \/\/ Special merge for arrays of identifiable items","    @Merged(using: .arrayOfIdentifiableMerge) var comments: [Comment] = []","    ","    \/\/ Use set merging for unordered collections","    @Merged(using: .setMerge) var categories: Set<String> = []","    ","    \/\/ Use dictionary merging for key-value data","    @Merged(using: .dictionaryMerge) var metadata: [String:String] = [:]","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"Available Merge Strategies","level":3,"anchor":"Available-Merge-Strategies"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":".textMerge"},{"type":"text","text":": Intelligently merges text changes in a way people would expect"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":".arrayMerge","type":"codeVoice"},{"type":"text","text":": Merges arrays by combining elements in an expected fashion"}]}]},{"content":[{"inlineContent":[{"code":".arrayOfIdentifiableMerge","type":"codeVoice"},{"type":"text","text":": Merges arrays of items conforming to "},{"type":"codeVoice","code":"Identifiable"},{"text":", ensuring uniqueness of IDs","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":".setMerge"},{"text":": Merges sets using set operations, handling conflicts in a way that is consistent with expections","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":".dictionaryMerge","type":"codeVoice"},{"type":"text","text":": Merges dictionaries by combining key-value pairs, handling conflicts in a way that is consistent with human expectations"}]}]}]},{"level":2,"text":"Working with Optional Properties","type":"heading","anchor":"Working-with-Optional-Properties"},{"type":"paragraph","inlineContent":[{"text":"ForkedModel handles optional properties seamlessly:","type":"text"}]},{"code":["@ForkedModel","struct NoteWithOptionals {","    var title: String = \"\"","    @Merged var description: String?","    @Merged(using: .arrayOfIdentifiableMerge) var items: [NoteItem]?","}"],"type":"codeListing","syntax":"swift"},{"text":"Custom Mergeable Types","anchor":"Custom-Mergeable-Types","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"You can use custom types that conform to "},{"type":"codeVoice","code":"Mergeable"},{"type":"text","text":" with "},{"code":"@Merged","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct Counter: Mergeable {","    var value: Int = 0","    ","    func merged(withSubordinate other: Self, commonAncestor: Self) throws -> Self {","        Counter(value: self.value + other.value - commonAncestor.value)","    }","}","","@ForkedModel","struct Document {","    @Merged var wordCount: Counter = Counter()","}"]},{"type":"heading","level":2,"text":"Recursive Merging","anchor":"Recursive-Merging"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Many of the merge algorithms will recursively apply merging to their contained elements if those elements conform to "},{"code":"Mergeable","type":"codeVoice"},{"type":"text","text":". This allows for sophisticated nested data structures:"}]},{"type":"codeListing","code":["@ForkedModel","struct Comment: Identifiable {","    var id: UUID = UUID()","    @Merged var text: String = \"\"","}","","@ForkedModel","struct BlogPost {","    @Merged var title: String = \"\"","    @Merged(using: .arrayOfIdentifiableMerge) var comments: [Comment] = []","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"In this example, when comments are merged:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":".arrayOfIdentifiableMerge"},{"text":" handles the array of comments","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"It ensures that when multiple comments with the same ID are encountered, they are properly merged","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Inside each ","type":"text"},{"code":"Comment","type":"codeVoice"},{"text":", the ","type":"text"},{"code":"text","type":"codeVoice"},{"type":"text","text":" is merged using text merging"}],"type":"paragraph"}]}],"type":"orderedList"},{"type":"paragraph","inlineContent":[{"text":"The same principle applies to dictionary values:","type":"text"}]},{"type":"codeListing","code":["@ForkedModel","struct Document {","    @Merged(using: .dictionaryMerge) var sections: [String: Comment] = [:]","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"When merging the dictionary, if the values for a given key are ","type":"text"},{"type":"codeVoice","code":"Mergeable"},{"type":"text","text":", they will be merged recursively rather than just taking the most recent value."}]},{"text":"Important Notes","level":2,"type":"heading","anchor":"Important-Notes"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"All non-optional stored properties must have default values","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"@ForkedModel","type":"codeVoice"},{"text":" macro automatically makes your type conform to ","type":"text"},{"code":"Mergeable","type":"codeVoice"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Equatable properties without ","type":"text"},{"type":"codeVoice","code":"@Merged"},{"type":"text","text":" will use a “most recent wins” strategy, in a property-wise fashion"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Non-equatable properties without ","type":"text"},{"code":"@Merged","type":"codeVoice"},{"type":"text","text":" will use a “most recent wins” strategy for the entire struct"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The merging strategy is determined at compile time and cannot be changed at runtime","type":"text"}]}]}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"kind":"article","identifier":{"interfaceLanguage":"swift","url":"doc:\/\/ForkedModel\/documentation\/ForkedModel\/ForkedModel"},"sections":[],"references":{"doc://ForkedModel/documentation/ForkedModel":{"abstract":[],"kind":"symbol","type":"topic","role":"collection","identifier":"doc:\/\/ForkedModel\/documentation\/ForkedModel","title":"ForkedModel","url":"\/documentation\/forkedmodel"}}}